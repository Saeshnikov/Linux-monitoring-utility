Утилита **ss**.

Команда ss — это инструмент, используемый для вывода сетевой статистики. ss даёт подробные сведения о TCP-подключениях и о состояниях соединений. В частности, ss может выводить данные о таких сущностях, как PACKET, TCP, UDP, DCCP, RAW, и сокеты домена Unix. С помощью ss можно получить подробные сведения о том, как машина, работающая под управлением Linux, обменивается данными с другими компьютерами.

Эта утилита уже предустановлена и в Debian и в Ubuntu.

Основы ss.

Если запустить ss без аргументов командной строки или опций, она выведет полный список активных соединений (TCP и сокеты).

В выводе мы видим следующие поля:

- Netid — тип подключения:

- u\_dgr — тип сокета, который работает без установки соединения;
- u\_str — тип сокета, который работает с предварительной установкой соединения;
- tcp — tcp соединение;
- udp — udp соединение.

- State — состояние соединения (сеанса TCP):
  - CLOSED — начальное состояние;
  - LISTEN — сервер ожидает запросы от клиента;
  - SYN-SENT — клиент хочет установить соединение с сервером и ожидает подтверждение;
  - SYN-RECEIVED — сервер получил запрос на создание сеанса, отправил ответный запрос и ожидает подтверждение;
  - ESTABLISHED — соединение установлено, идёт передача данных;
  - FIN-WAIT-1 — одна из сторон завершает соединение, отправив флаг FIN;
  - CLOSE-WAIT — другая сторона переходит в это состояние, отправив подтверждение на FIN, но продолжает передачу;
  - FIN-WAIT-2 — первый узел получил ACK, разорвал свое соединение, но еще читает данные;
  - LAST-ACK — второй узел заканчивает передачу и отправляет флаг FIN;
  - TIME-WAIT — сервер получил пакет с флагом FIN, отправил флаг ACK и ждёт некоторое время, перед окончательным закрытием соединения;
  - CLOSING — обе стороны инициировали закрытие соединения одновременно.
- Recv-Q — количество байтов, помещённых в буфер приёма TCP/IP, но не переданных приложению. Если это число высокое, то нужно проверить работоспособность приложения, которое работает с данным портом.
- Send-Q — количество байтов, помещённых в буфер отправки TCP/IP, но не отправленных, или отправленных, но не подтверждённых. Высокое значение может быть связано с перегрузкой сети сервера.
- Local Address:Port — локальный адрес и порт сервера. Либо файл сокета. В LISTEN соединениях — это диапазон адресов и портов.
- Peer Address:Port — адрес и порт второй стороны. В LISTEN соединениях — это диапазон адресов и портов.
- Process — информация о процессе, которая появляется только, когда мы используем опцию -p.

Опции.

- **-h, -- help**:отобразить сводку опций.
- **-V, -- version**:вывод информации о версии.
- **- H, --no-header**:подавить строку заголовка.
- **-O, -- oneline**: вывести данные каждого сокета в одной строке.
- **-n, --numeric**:

не переводить номера процессов в имена протоколов; показывать точные значения пропускной способности вместо удобочитаемых.

- **-r, --resolve**: попытаться перевести числовой адрес/порты.
- **-a, --all**:

отображать как прослушивающие, так и не прослушиваемые (для TCP это означает установленные соединения) сокеты.

- **-l, --listening** :

отображать только прослушивающие сокеты (по умолчанию они опущены).

- **-p, --processes** :показать процесс, использующий сокет.
- **-o, --options** :

Отображать информацию о таймере. Формат вывода для протокола TCP:

timer:(\<timer\_name\>,\<expire\_time\>,\<retrans\>)

**\<timer\_name\>**

название таймера, существует пять видов названий таймера:

- **on** : таймер повторной передачи TCP, таймер ранней повторной передачи TCP и таймер проверки потери хвоста;
- **keepalive** : таймер поддержания активности TCP;
- **timewait** : таймер этапа ожидания;
- **persist** : таймер проверки нулевого окна;
- **unknown** : ни один из вышеперечисленных таймеров.

**\<expire\_time\>** : через сколько времени истечет срок действия таймера

**\<retrans\>** : сколько раз происходила повторная передача

- **-e, --extended**

Отображать подробную информацию о сокете. Формат вывода:

uid:\<uid\_number\> ino:\<inode\_number\> sk:\<cookie\>

**\<uid\_number\>** : идентификатор пользователя, которому принадлежит сокет

**\<inode\_number\>** : индексный номер сокета в VFS

**\<cookie\>** : uuid сокета

- **-m, --memory**

Показать использование памяти сокета. Формат вывода:

skmem:(r\<rmem\_alloc\>,rb\<rcv\_buf\>,t\<wmem\_alloc\>,tb\<snd\_buf\>,

f\<fwd\_alloc\>,w\<wmem\_queued\>,o\<opt\_mem\>,

bl\<back\_log\>,d\<sock\_drop\>)

**\<rmem\_alloc\>** : память, выделенная для приема пакета

**\<rcv\_buf\>** :

общий объем памяти, который может быть выделен для приема пакета

**\<wmem\_alloc\>** :

память, используемая для отправки пакета (который был отправлен на уровень 3)

**\<snd\_buf\>** :

общий объем памяти, который может быть выделен для отправки пакета

**\<fwd\_alloc\>** :

память, выделенная сокетом в качестве кэша, но еще не используемая для приема/отправки пакета. Если для отправки/получения пакета требуется память, память в этом кэше будет использована до выделения дополнительной памяти.

**\<wmem\_queued\>** :

память, выделенная для отправки пакета (который не был отправлен на уровень 3)

**\<opt\_mem\>** :

память, используемая для хранения параметра сокета, например ключа для TCPMD5 сигнатуры

**\<back\_log\>** :

память, используемая для skbacklogqueue. В контексте процесса, если процесс получает пакет и получен новый пакет, он будет помещен в очередь, чтобы процесс мог немедленно его получить

**\<sock\_drop\>** :

количество пакетов, отброшенных до того, как они будут демультиплексированы в сокет

- **-T, --threads**: показать поток, использующий сокет. Подразумевает** - **p**.
- **-i, --info**

Отображать внутреннюю информацию TCP. Могут отображаться поля, указанные ниже:

**ts** :показывать строку "ts", если задана опция временной метки

**sack** : показывать строку "sack", если задана опция sack

**ecn** :показывать строку "ecn", если установлена опция явного уведомления о перегрузке

**ecnseen** : показывать строку "ecnseen", если флаг sawecn обнаружен в полученных пакетах

**fastopen** : показывать строку "fastopen", если установлена опция fastopen

**cong\_alg** :

название алгоритма перегрузки, алгоритм перегрузки по умолчанию – «кубический»

**wscale:\<snd\_wscale\>:\<rcv\_wscale\>** :

если используется параметр масштабирования окна, в этом поле отображается коэффициент масштабирования отправки и коэффициент масштабирования получения

**rto:\<icsk\_rto\>**:

значение тайм-аута повторной передачи tcp, единица измерения - миллисекунда

**backoff:\<icsk\_backoff\>**:

используется для экспоненциальной повторной передачи с задержкой, фактическое значение тайм-аута повторной передачи равно icsk\_rto \<\< icsk\_backoff

**rtt:\<rtt\>/\<rttvar\>**:

rtt - среднее время цикла обработк, rttvar - среднее отклонение rtt, их единицы измерения - миллисекунды

**ato:\<ato\>**:

ack тайм-аут, единица измерения - миллисекунда, используется для режима задержки подтверждения

**mss:\<mss\>**: максимальный размер сегмента

**cwnd:\<cwnd\>**: размер окна перегрузки

**pmtu:\<pmtu\>**: значение MTU пути

**ssthresh:\<ssthresh\>**: порог медленного запуска окна перегрузки tcp

**bytes\_acked:\<bytes\_acked\>** : подтвержденные байты

**bytes\_received:\<bytes\_received\>** : полученные байты

**segs\_out:\<segs\_out\>** : разосланные сегменты

**segs\_in:\< segs\_in\>**: полученные сегменты

**send \<send\_bps\>bps** : egress bps

**lastsnd:\<lastsnd\>**:

сколько времени прошло с момента отправки последнего пакета, единица измерения - миллисекунда

**lastrcv:\<lastrcv\>**:

сколько времени прошло с момента получения последнего пакета, единица измерения - миллисекунда

**lastack:\<lastack\>**:

сколько времени прошло с момента получения последнего подтверждения, единица измерения - миллисекунда

**pacing\_rate \<pacing\_rate\>bps/\<max\_pacing\_rate\>bps** :

частота поступления и максимальная частота поступления

**rcv\_space:\<rcv\_space\>**:

вспомогательная переменная для внутренней автоматической настройки буфера приема сокета TCP

**tcp-ulp-mptcp flags:[MmBbJjecv]**

**token:\<rem\_token(rem\_id)/loc\_token(loc\_id)\> seq:\<sn\>**

**sfseq:\<ssn\> ssnoff:\<off\> maplen:\<maplen\>** :

информация о подпотоке MPTCP

- **--tos**

Показывать ToS и информацию о приоритетах. Могут отображаться поля, указанные ниже:

**tos** : IPv4 Type-of-Service byte

**tclass** : IPv6 Traffic Class byte

**class\_id** :

Идентификатор класса, заданный net\_clscgroup. Если класс равен нулю, это показывает приоритет, установленный SO\_PRIORITY.

- **--cgroup** :

Отображать cgroup информацию. Могут отображаться поля, указанные ниже:

**cgroup** :путь к Cgroupv2. Этот путь относится к точке монтирования иерархии.

- **--tipcinfo** :

Отображать информацию о внутреннем сокете tipc.

**-K, --kill**:

Пытается принудительно закрыть сокеты. Этот параметр отображает сокеты, которые успешно закрыты, и автоматически пропускает сокеты, закрытие которых ядро не поддерживает. Он поддерживает только сокеты IPv4 и IPv6.

**-s, --summary**:

Вывод сводной статистики. Эта опция не анализирует списки сокетов, получая сводку из различных источников. Это полезно, когда количество сокетов настолько велико, что разбор /proc/net/tcp является болезненным.

**-E, --events**: Постоянно отображать сокеты по мере их разрушения

**-Z, --context**:

Как параметр -p, но также показывает контекст безопасности процесса. Если используется параметр -T, также отображается контекст безопасности потока.

**-z, --contexts**:

Как параметр -Z, но также показывает контекст сокета. Контекст сокета берется из связанного inode и не является фактическим контекстом сокета, хранящимся в ядре. Сокеты обычно помечаются контекстом процесса создания, однако показанный контекст будет отражать любую применяемую роль политики, тип и/или правила перехода диапазона и, следовательно, является полезной ссылкой.

**-N NSNAME, --net=NSNAME** :

Переключитесь на указанное имя сетевого пространства имен.

**-b, --bpf**: показывать фильтры socketclassicBPF.

**-4, --ipv4** : отображать только сокеты IP версии 4 (псевдоним для -finet).

**-6, --ipv6** : отображать только сокеты IP версии 6 (псевдоним для -finet6).

**-0, --packet**: отображать сокеты ПАКЕТОВ (псевдоним для ссылки -f).

**-t, --tcp**: отображать TCP-сокеты.

**-u, --udp**: отображать UDP-сокеты.

**-d, --dccp**:отображать DCCP сокеты.

**-w, --raw**: отображать RAW сокеты.

**-x, --unix**: отображать доменные сокеты Unix (псевдоним для -funix).

**-S, --sctp**: отображать SCTP-сокеты.

**--tipc**: отображать сокеты tipc (псевдоним для -ftipc).

**--vsock**: отображать сокеты vsock (псевдоним для -fvsock).

**--xdp**: отображать сокеты XDP (псевдоним для -fxdp).

**-M, --mptcp**: отображать MPTCP сокеты.

**--inet-sockopt**: отображать параметры встроенного сокета.

**-f FAMILY, --family=FAMILY** :

Отображатьсокетытипа FAMILY. В настоящее время поддерживаются следующие семейства: unix, inet, inet6, link, netlink, vsock, tipc, xdp.

**-A QUERY, --query=QUERY, --socket=QUERY** :

Список таблиц сокетов для выгрузки, разделенных запятыми. Понятны следующие идентификаторы: all, inet, tcp, udp, raw, unix, пакет, netlink, unix\_dgram, unix\_stream, unix\_seqpacket, packet\_raw, packet\_dgram, dccp, sctp, tipc, sock\_stream, sock\_dgram, xdp, mptcp. Любой элемент в списке может быть дополнен восклицательным знаком (!), чтобы исключить сброс этой таблицы сокетов.

**-D FILE, --diag=FILE** :

Ничего не отображать, просто выгрузить необработанную информацию о TCP-сокетах в файл после применения фильтров. Если ФАЙЛ равен -, то используется стандартный вывод.

**-F FILE, --filter=FILE** :

Считывание информации о фильтре из ФАЙЛА. Каждая строка ФАЙЛА интерпретируется как отдельный параметр командной строки. Если файл имеет значение -, то используется stdin.

Поиск определённых соединений.

- Поиск того, кто слушает определенный (например, 22) порт на нашем сервере:

**sudo ss -ltpn | grep 22**

- Поиск соединения по статусу соединения или порту отправителя и порту получателя:

**ss state established '( dport = :ssh or sport = :ssh )'**

- Поиск всех подключений с определённого ip адреса:

**ss dst 192.168.0.14**

- Поиск соединения только с локальным (например, 80) портом:

**ss src :80**

Проверить все открытые порты:

**sudo ss -tulpn**

Результат команды можно также вывести в файл (например, ss\_output):

**ss \> ss\_output**